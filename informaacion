#Scaffold --> Para crear modulos configurados mediante codigo desde la terminal
odoo-bin.py 
python odoo-bin scaffold my_module addons_path/customer_addons 
my_module = el nombre del modulo
addons_path/customer_addons = la ruta donde se creara ese modulo

#_sql_constraints = [
  ("unique_number_document","unique(number_document)","!!!....No puede haber Documentos iguales.....!!!!") --> 
]
unique_number_document -> puede ser cualquier nombre que desees

#Views 
 <!--View Graph-->
        <record id="movie_presupuesto_view_graph" model="ir.ui.view">
            <field name="name">movie.presupuesto.view.graph</field>
            <field name="model">movie.presupuesto</field>
            <field name="arch" type="xml">
                <graph string="Grafico">
                    <field name="customer_id" type="row"/>
                </graph>
            </field>
        </record>

        <!--View Calendar-->
        <record id="movie_presupuesto_view_calendar" model="ir.ui.view">
            <field name="name">movie.presupuesto.view.calendar</field>
            <field name="model">movie.presupuesto</field>
            <field name="arch" type="xml">
                <calendar string="Calendar" date_start="date_pre" mode="month">
                    <field name="name"/>
                </calendar>
            </field>
        </record>

        <!--View Pivot-->
        <record id="movie_presupuesto_view_pivot" model="ir.ui.view">
            <field name="name">movie.presupuesto.view.pivot</field>
            <field name="model">movie.presupuesto</field>
            <field name="arch" type="xml">
                <pivot string="Pivot">
                    <field name="name" type="row"/>
                </pivot>
            </field>
        </record>

#filtered y mapped
sale.filtered(lambda s: s.price>100) --> te filtra el resultado en una lista
sale.mapped("name") --> te devuelve el registro del campo name en una lista
#Campos One2many
En Odoo, el campo "one2many" se utiliza para establecer relaciones entre registros de dos modelos diferentes. Las tuplas que mencionaste, como (0, 0, { valores }), (1, ID, { valores }), etc., se utilizan para definir las operaciones que se pueden realizar en ese campo. Aquí está una explicación de cada una:

(0, 0, { valores }): Esta tupla crea un nuevo registro vinculado al campo "one2many" con los valores proporcionados en el diccionario "valores".

(1, ID, { valores }): Actualiza el registro vinculado con el ID especificado con los nuevos valores proporcionados.

(2, ID): Elimina y borra el registro vinculado con el ID especificado. Esto borrará completamente el objeto y su relación en el campo "one2many".

(3, ID): Corta la relación con el registro vinculado con el ID especificado, pero no elimina el objeto en sí. En otras palabras, elimina la relación, pero el registro vinculado permanece en la base de datos.

(4, ID): Establece una relación con un registro existente que tiene el ID especificado en el campo "one2many".

(5): Desvincula todos los registros vinculados en el campo "one2many". Es similar a usar (3, ID) para cada registro vinculado.

(6, 0, [IDs]): Reemplaza la lista de registros vinculados con los IDs proporcionados. Esto es como desvincular todos los registros existentes usando (5) y luego vincular los nuevos registros usando (4, ID) para cada ID en la lista de IDs.
Estas tuplas se utilizan en las listas de comandos de "one2many" para especificar las operaciones que se deben realizar en los registros vinculados. Por ejemplo, si deseas agregar un nuevo registro, usarías (0, 0, { valores }), y si deseas eliminar un registro existente, usarías (2, ID).

#En las relaciones Many2many puedes cambiar el nombre de la tabla intermedia,los ids de las relaciones a tu antojo, si no lo describes
odoo lo crea por defecto:
relation='nombre de la tabla intermedia'
column1=nonbre del id de la tabla1
column2=nombre de id de la tabla2
 tag_ids = fields.Many2many(string="Etiquetas",comodel_name="bo.tag",relation="bo_inmueble_tag_rel",column1="inmueble_id",column2="tag_id") 

import logging

_logger = logging.getLogger(__name__) 

#Dato
COmo sabemos si un registro un campo active=False , el registro se ocultara desde la interfaz,pero si tenemos un campo related que relaciona  auna tabla el cual uno de sus campos
el campo active = False, entonces ese campo dela tabla 2 no se ocultara , semotrara con normalidad.
#Grupos
-para saber si un usuario pertence a un grupo desde python se usa:
self.env.user.has_group('modulo.fddff') --> si encaso esta en el grupo te devuelve True en caso contrario de devuelve un False
if self.env.user.has_group('purchase_albaran.group_edition_pl_sin_restriccion_order_production_plp'):

-AHora en las vistas 
<field name="name" groups="account.group_account_manager"/> --> le estoy diciendo que este campo sera visible si el usuario se encuentra en ese grupo caso contrario no lo podra ver
ojo el groups="grupo1,grupo2,etc" --> puede aver mas de un grupo 
ejemplo
groups="account.group_account_manager, account.group_account_invoice, account.group_account_tesoreria, account.group_account_user"/>

#OJO COROJO
En odoo cuando tenemos campos Many2one(foreign key) Many2many a estos campos si no se inserta informacion podria salir error por que solo permiten ecibir Null,0,1
ahora cuando dejamos en blanco esos campos , los metodos create(),write()  por detras hace que esos cmapos que dejo en blanco al momento de crear o actualizar ,los convierte el False a  Null
para que de esta manera Postgres no me arroje error
-campos en blanco se transforman en False.
 AHora cuando realizamos querys con el self.env.cr.execute() me saldra ese error por que los campos Foreign key no permite valores boolean por ello 
use este codgo self.nacionality_id.id if self.nacionality_id else None.Lo que hago es que si el campo esta en blanco le envio un None que en python significa Null

#para ingresar a la consola de odoo y testear usamos python odoo-bin shell -c odoo.conf -d name_db
para hacer un create,write,unlink al final se tiene que guardar con este comando self.env.cr.commit
item.search(['|',('type_item','=','otro'),('type_item','=','hadware')]) --> '|' es O

#Ojo cuando deses filter para igualar un objeto con otro objeto
ejemplo:
class Customer(models.Model):
    _name="minimarket.customer"
    product_id=fields.Many2one(string="Producto",comodel_name="minimarket.product")
    
 class CustomerWizard(models.Model):
    _name="minimarket.customer"
    product_id=fields.Many2one(string="Producto",comodel_name="minimarket.product")
    
     def imprimir_xlsx(self):
        data={
            'product_id':self.product_id.id,
        }
        return self.env.ref('minimarket.action_report_xlsx_minimarket_customer').report_action(self,data=data)

cuando desee igualar  en un clase para reporte xlsx como ejemplo 
class ReportCustomerxlsx(models.AbstractModel):
    _name="report.minimarket.report_xlsx_customer"
    _inherit="report.report_xlsx.abstract"

    @api.model
    def generate_xlsx_report(self,workbook,data,partners):
    	 obj_customer=self.env['minimarket.customer'].search([('product_id','=',data.get('product_id'))])
	 en este eejmplo estoy igualando un objeto=id(el id es numerico)
	 lo que hacia era igualar un 'product_id','=',data.get('product_id')--> pero al hacer esto me arrojaba nada
	 al parecer cuando quieres igualar un objeto debes hacerlo con su id numerico
	 asi seria:
	 obj_customer=self.env['minimarket.customer'].search([('product_id','=',1)])


widget=EFectos VIsuales
<widget name="web_ribbon" title="Archivado" bg_color="bg_danger"/>
<field name="puntuacion" widget="percentpie"/>
<fiel name="name_campo" widget="boolean_toggle"/>
<field name="name_campo" widget="url"/>
<field name="name_campo" states="borrador"/> --> Le estoy diciendo que el field sera visible cuando el estado del state_presupuesto este en borrador 
ejemplo:
<field name="state"/>--> actualmente esta en estado borrador
ojo el campo tiene que llamarse obligatoriamente state=fields.Selection(selection=[('aprobado','Aprobado'),('borrador','Borrador')] , por que si no , el atributo states="borrador" no funcionara

-En resumen, la clase "oe_avatar" se utiliza para definir la apariencia de las imágenes de perfil de usuario y los iconos de menú en la interfaz de usuario de Odoo 16. Esta clase se utiliza en la plantilla base "web.assets_backend" y en la plantilla "web.menu" para definir la apariencia de la barra lateral y los menús de la interfaz de usuario.

-En resumen, la clase "oe_title" se utiliza para definir el estilo de los títulos en la interfaz de usuario de Odoo 16. Esta clase se utiliza en varias plantillas de Odoo para definir el estilo de los títulos de sección y los títulos de registro en la vista de formulario y la vista de lista.

-En resumen, la clase "o_row" se utiliza para definir el estilo de las filas en las tablas de la interfaz de usuario de Odoo 16. Esta clase se utiliza en varias plantillas de Odoo para definir el estilo de las filas que muestran los registros y los campos en la vista de lista y la vista de formulario.

En resumen, self.env.ref('aca_se pone external_id.id_record') -->ref('movies.data_director')
se utiliza en Odoo 16 para obtener un registro específico de la base de datos de Odoo utilizando su identificador único xml_id.

attributos de vistas
optional="show" -->mostrar se usa para vistas tree
optional="hide"--->ocultar se usa para vistas tree

decoraciones 
widget="badge"
decoration-bf-->negrita
decoration-it-->cursiva
decoration-danger-->rojo
decoration-info-->azul claro
decoration-muted-->gris claro
decoration-success-->verde
decoration-warning-->mostaza

condiciones con estas decoraciones 
ejemplo
&gt -> Mayor que
&lt -> Menor que
<field name="" decoration-info=" field == 'aprobado'"/>
<field name="" decoration-info=" field &gt 100"/> 
<field name="" decoration-info=" field &lt 100"/>

#En Odoo 14, la clase "oe_button_box" se utiliza para definir un contenedor de botones en la interfaz de usuario de Odoo. Esta clase se utiliza para agrupar un conjunto de botones relacionados en una sola área de la pantalla
<div class="oe_button_box" name="button_box">
    <button class="oe_highlight" icon="" >Guardar</button> -->icon="" te mostrara el icono de font awesome
    <button class="oe_secondary">Cancelar</button>
    <a href="#" class="oe_inline">Más información</a>
</div>

options
Atributos de campo de view
domain=Filtracion --> <field name="category_id" domain=[('','',')]
context=pasa valor por defecto
OJo si paso un valor por el context desde un ir.actions.act_window para poder obtener el valor en el model se usa self.env.context y para obtenerlo directo en la view sea form,tree se usa 
<field name="campo1" invisible="context.get('')"/> el context.get() obtiene el valor pasado desde el context
attrs=invisible,readonly,required ---> <field name="" attrs="{'invisible':True}"
options=no_quick_create-->no crear(te oculta la opcion de crear), no_create_edit-->no crear y eitar(te quita la opcion de crear y editar)  no_open-->te oculta el cuadradito que te permite abrir formulario de un model
<field name="field" options="{'no_create':True}"
OJO: cuando tu didgitas un nombre en un vista en un campo Many2one por defecto te mostrar Create , create y edit, Buscar mas
options=no_quick_create-->no crear(te oculta la opcion de crear)
no_create_edit-->no crear y eitar(te quita la opcion de crear y editar)
Tipos de Monedas
creas un campo para ver el tipo de moneda que seleccionaras
currency_id=fields.Many2one(comodel_name="res.currency")

ahora en la view form

<field name="amount" widget="monetary" options="{'currency_field':'currency_id'}"
  <record id="ir_rule_user_free_own_information_university_student" model="ir.rule">
        <field name="name">Informacion Propia Student</field>
        <field name="model_id" ref="university.model_university_student"/>
        <field name="groups" eval="[(4,ref('res_groups_university_user_free'))]"/><!--asociando esta regla a un grupo existente-->
        <field name="domain_force">
            [('create_uid','=',user.id)]<!--create_uid es el di que por defecto se agrega a las tablas de odoo para de este modo saber que usuario esta registrando,creando,eliminado informacion-->
        </field>
        <field name="perm_read">1</field>
        <field name="perm_write">1</field>
        <field name="perm_create">1</field>
        <field name="perm_unlink">1</field>
 </record
 
 #view de tipo search
 <record id="biblioteca.view_search_library_book" model="ir.ui.view">
        <field name="name">biblioteca.view.search.library.book</field>
        <field name="model">library.book</field>
        <field name="arch" type="xml">
            <search>
                <field name="codigo"/>
                <field name="name"/>
                <field name="author_id"/>

                <filter string="Literatura" name="filter_literatura" domain="[('type_books','=','literatura')]"/>
                <filter string="Cuento" name="filter_cuento" domain="[('type_books','=','cuento')]"/>
                <filter string="Novela" name="filter_novela" domain="[('type_books','=','novela')]"/>
                <filter string="Peomas" name="filter_poema" domain="[('type_books','=','poema')]"/>
                <!--group by-->
                <filter string="Type Books" name="group_type_book" context="{'group_by':'type_books'}"/>---> agrupando  el name puede ser cualquerira
            </search>
        </field>
    </record>


<record id="library_book_action" model="ir.actions.act_window">
            <field name="name">Pelicula</field>
            <field name="res_model">library.book</field>
            <field name="view_mode">tree,form</field>
            <field name="target">current</field>
            <field name="context">
                {
                    'search_default_filter_cuento':True --> mediante el context asi como puedo pasar data por defecto a los campos de un model,
							    tambien puedo pasar filter por defecto mediante el contex pero se antepone antes el search
							    ejemplo:search_default_filter_cuento: antepongo el search luego del default y luego el name del filter 
							   y lo igualo a un True de este modo le estoy diciendo que por defecto me envie la vista filtrar del 
							    filter name="filter_cuento"
                }
            </field>
</record>
 #campos compute
 los campos que tengan como atributo compute, en la base datos no se almacenan pero si deseas que se almacene se usa el attributo store=True
 quanty=fields.Float(compute='compute_total',store=True)
 
 Sentencia SQL
  def filter_date(self):
        fuel_litres=100
        sql="SELECT * FROM test_car WHERE fuel_litres<{}".format(fuel_litres)
        self.env.cr.execute(sql)
        result=self.env.cr.fetchall()---> Transforma el resultado en un array de tuplas
         result=self.env.cr.dictfetchall()---> Transforma el resultado en un array de diccionarios
        print(result)
 
 #Sobreescribiendo el name_get(self) que viene por defecto
   class test:
     _rec_name = "customer_id"  --> lo que hace esto es que el name por defecto sera lo que contiene el customer_id , la diferencia con name_get es
     que en name_get puedes personalizar a tu antojo 
    def name_get(self):
        result=[]
        for user in self:
            name="{}(+{})".format(self.name,self.phone)
            result.append((user.id,name))-->Necesita el Id del register y luego va el nombre que deseas que aparesca
        return result
        
        
Tipos de excepciones en Odoo
Las excepciones se utilizan en programación para alertar de situaciones anómalas que suceden durante la ejecución de una aplicación o programa. En Odoo se utilizan con el mismo objetivo y la manera de implementarlas es utilizando la palabra reservada raisedel lenguaje Python. La forma en la que se presentan al usuario es mediante una ventana en la parte superior del navegador en la que se muestra el tipo de excepción y el mensaje asociado.

Veamos ahora los diferenrtes tipos de excepciones que podemos manejar en Odoo:

odoo.exceptions.AccessDenied: Se utiliza cuando se debe denegar el acceso a una determinada parte de la aplicación cuando los datos que se esperan no son los obtenidos.

odoo.exceptions.AccessError: Se utiliza para mostrar que el usuario en sesión no dispone de accesos de algún tipo a algún recurso.

odoo.exceptions.CacheMiss: Se emplea cuando se trata de acceder a un registro en caché que ya no existe.

odoo.exceptions.MissingError: Se utiliza para denotar que se trata de modificar un registro que ya se encuentra borrado con anterioridad.

odoo.exceptions.RedirectWarning: Se utiliza para, además de mostrar un mensaje al usuario (advertencia), redirigir a otra vista por medio de una acción. La función recibe dos parámetros: el ID de la acción a la que tratamos de redirigir al usuario y el mensaje que se quiere mostrar al usuario.

odoo.exceptions.UserError: Se emplea cuando un usuario trata de agregar un valor a un registro y el estado del registro no es el correcto porque no se cumplen ciertas condiciones.

odoo.exceptions.ValidationError: Se aplica cuando las condiciones que afectan a un determinado registro fallan.

#posiciones para herencias
div[1] empieza con el 1

#obtener los parametros de la url de un model en odoo
def test(self):
        print(self)--> Llama al objeto
        print(self._context)-->{
                                  'lang': 'es_PE',
                                  'tz': False,
                                  'uid': 1,
                                  'allowed_company_ids': [
                                    1
                                  ],
                                  'params': {
                                    'id': 8,
                                    'cids': 1,
                                    'menu_id': 72,
                                    'action': 88,
                                    'model': 'minimarket.product',
                                    'view_type': 'form'
                                  }
                                }
        
        
   #compañias
   self.env.company.currency_id --> moneda de la compañia  recuerda que cuando uso self.env.company estos accediendo a la tabla res.company
   la diferencia es que me muestra la compañia actual en la que estoy en el odoo, esto pasa lo mismo con el self.env.user(muestra la informacion del
   usuario actual)
   self.env.user.company_id.id --> te arroja el id de la compañia en la que esta logeado el usuario
   self.env['res.company']--->te muesytras las empresas que tiene Odoo
   cada eempresa tiene un id
      self.env['res.company'].search([('id','=',1)]).logo_web  obtiene la ruta del logo de la empresa con id =1

cada usuario tiene un campo 'company_id' que relaciona con la tabla copania
sudo()--> te permite tener todas los permisoso de administradores
data=self.env['hr.employee'].sudo().search([('company_id.id','=',self.env.user.company_id.id)])

#Se puede incrsutar function a un campo como default
class Prueba(models.Model):
    _name="test_prueba"

    def get_date(self):
        data=datetime.now()
        data_edit=data-timedelta(hours=5)
        return data_edit

    fecha1=fields.Datetime(string="Fecha1",default=get_date)
    
  #qweb puedes obtener una function del model desde la qweb mediante objetos
  def get_date_qweb(self):
        data=datetime.now()
        data_edit=data-timedelta(hours=5)
        return data_edit
  <template>
    <t t-foreach="docs" t-as="o">
        #Aca estamos instanciando la variable o  a cada objeto del model , asi como o puede acceder a cualquier campo tambien puede acceder a functiones
        <t t-esc="o.get_date_qweb()"/>
    </t>
  </template>

#api.onchange('') --> el api onchange se activa cuando editas un campo que referencias en el onchange pero
al seleccionar el button create(cuando se selecciona el button Nuevo o create nuevo registro) esto sucedera sin inportar 
que en el onchange('') dependa de que un campo se actualize,se activan todos los onchnages que esten en tu model

#oe_chatter
# agregando caja de seguimeinto o_chatter

class Model(models.Model)
   _name='mimodel'
   inherit="mail.thread"
   
   
depends:[
	'mail'
]


   <div class="oe_chatter">
        <field name="message_follower_ids widget="mail_followers""/>
        <!-- <field name="activity_ids"/> -->
        <field name="message_ids"/>
    </div>
#COMPUTE
-La function compute no almacena en la Base Datos pero si es visible el valor del campo en la view, si pones store=True se almacena en la BD pero no se vera en la view
-la function compute se aplica cuando uno renderisa la pagina ,cllickea en create,etc.
-#onchange
la function onchange se aplica cuando actualizas ciertos campos  y se activan todos los onchanges creados en el model cuando seleccionas el button create 

####PYTHON###3
Fechas
import datetime
datetime.datetime.now()--> te muestra la fecha y hora actual  2023-05-09 14:20:12.955428
datetime.datetime.now().strftime("%H:%M.%S")---> Te muestra la hora actual port el strftime 14:20:52
datetime.timedelta(hours=5) --> te muestra la hora en este caso le estoy diciendo muestrame 5 horas 5:00:00
datetime.timedelta(hours=19) --> te muestra la hora en este caso le estoy diciendo muestrame 19 horas 19:00:00
strftime("%m/%d/%Y, %H:%M:%S")


#Report PDF
<record id="minimarket.action_report_product" model="ir.actions.report">
            <field name="name">Reporte Producto</field>
            <field name="model">minimarket.product</field>
            <field name="report_type">qweb-pdf</field>
            <field name="report_name">minimarket.report_product</field> --> el report name(report_product) debe coincidir en el id del template para que de este modo lo vincule
            <field name="binding_type">action</field>
            <field name="paperformat_id" ref="minimarket.paperformat_producto"/>
            <field name="print_report_name">'Reporte Producto'</field>
 </record>
 
class ProductWizard(models.TransientModel):
    _name="minimarket.product.wizard"
    _description="Wizard de Product"


    date_to=fields.Datetime(string="Fecha Inicio")
    date_end=fields.Datetime(String="Fecha Hasta")

    def get_pdf(self):
        data = {
            'date_to':self.date_to,
            'date_end':self.date_end
        }
        return self.env.ref('minimarket.action_report_product').report_action(self,data=data)
	
class ReportProductAbstract(models.AbstractModel):
    _name='report.minimarket.report_product' -->el report_product es el report_name del ir.actions.report

    @api.model
    def _get_report_values(self,docids,data=None):
        data={
           
        }
        return data --> envia la data al template

#Reporte en excel
module report.xlsx

 def get_test(self):
 	data={}
        return self.env.ref('minimarket.action_report_customer_xlsx').report_action(self,data=data)

 <record id="minimarket.action_report_customer_xlsx" model="ir.actions.report">
            <field name="name">Reporte Producto XLSX</field>
            <field name="model">minimarket.customer</field>
            <field name="report_type">xlsx</field>
            <field name="report_name">minimarket.report_customer_xlsx</field>
            <field name="print_report_name">'Reporte Customer XLSX'</field>
        </record>
	
from odoo import models,fields,api


class ReportCustomerxlsx(models.AbstractModel):
    _name = 'report.minimarket.report_customer_xlsx'
    _inherit = 'report.report_xlsx.abstract'

    @api.model
    def generate_xlsx_report(self, workbook, data, partners):
        sheet=workbook.add_worksheet("Customer")
        format1=workbook.add_format({'bold':True})
        sheet.write(0,0,'Nombre',format1)


#ACCIONES DE TIPO SERVIDOR
class Customer(models.Model):
    _name="minimarket.customer"
    
    def get_customer(self):
        self.type_customer="deudor"

<record id="minimarket.action_server_minimarket_customer" model="ir.actions.server">
            <field name="name">Tipo Cliente</field>
            <field name="model_id" ref="minimarket.model_minimarket_customer"/>
            <field name="state">code</field>
            <field name="code">
                for rec in records:--->records contiene todos los registros seleccionados desde la vista 
                    rec.get_customer()
            </field>
 </record>

#Ojo cuando desees registrar un objeto
no se puede registrar un objeto completo , basta solo con el id del objeto ,para registrarlo a un campo many2one por que si no saldra error
#Para obtener los datos que envio desde un context hacia un model desde el ir.actions.act_window
se usa self.env.context


# OBteniendo data de un model desde el context y realizando el query 
class WizardUpdatePresupuesto(models.TransientModel):
    _name="cinestar.update_presupuesto_wizard"

    STATE_PRESUPUESTO=[
        ('Borrador','borrador'),
        ('Aprobado','aprobado'),
        ('Publicado','publicado')
    ]
    
    name=fields.Char(string="Pelicula")
    description=fields.Text(string="Descripcion")
    # image_movies=fields.Binary(string="Imagen")
    genero_id=fields.Many2one(string="Genero",comodel_name="cinestar.genero")
    date_streno=fields.Date(string="Estreno")
    duration=fields.Datetime(string="Duracion")
    clasification=fields.Selection(string="Clasificacion",selection=[
        ('menor_15','Menores a 15'),
        ('mayor_18','Mayores a 18')
    ],default='mayor_18')
    state=fields.Selection(selection=STATE_PRESUPUESTO)

    @api.multi
    def btn_write_presupuesto(self):
        id_presupuesto=self.env.context.get('id_presupuesto')
        print(id_presupuesto)

        query='''
            update cinestar_presupuesto
            set name= %s,
                description= %s,
                date_streno= %s,
                duration= %s,
                clasification= %s,
                genero_id= %s
                where id= %s
        '''

        self.env.cr.execute(query,(self.name,
                                    self.description,
                                    self.date_streno,
                                    self.duration,
                                    self.clasification,
                                    self.genero_id.id,
                                    self.env.context.get('id_presupuesto')))

        self.env.cr.commit()
#DEFAULT GET
    @api.model
    def default_get(self,fields):
        res=super(Presupuesto,self).default_get(fields)
        res['name']='Naruto'
        res['description']='Naruto SHippuden'
        res['genero_id']=self.env['cinestar.genero'].search([('id','in',[1])]).id
        # res['date_streno']=date.today()
        # res['duration']=datetime.now()
        res['state']='Publicado'
        res['clasification']='menor_15'
        res['name']='Gran JC'
        return res
Esto es lo mismo que el atributo default, hace la misma funcionalidad, fields son los nombres de los campos que te trae del model y la funcion default_get se activa solo , como el compute 

#PARA ODOO V8 en los report PDF
class  WizardAccountInvoice(models.TransientModel):
    _name="account_report_invoice_johao.wizard_account_invoice"

    date_from=fields.Date(string="Fecha Desde")
    date_to=fields.Date(string="Fecha Hasta")

    @api.multi
    def get_pdf(self):
        data={
            'date_from':self.date_from,
            'date_to':self.date_to
        }

        return self.env['report'].get_action(self,'account_report_invoice_johao.report_account_invoice',data=data) --> dentro del get_action se ponen el report_name del ir.actions.report.xml
#
class ReportAccountInvoice(models.AbstractModel):
    _name="report.account_report_invoice_johao.report_account_invoice"

    @api.model
    def render_html(self,docids,data=None):
        obj_account_invo=self.env['account.invoice'].search([
            ('date_invoice','>=',data.get('date_from',False)),('date_invoice','<=',data.get('date_to',False))
        ])
        print(obj_account_invo)
        print("**Enviando informacion al template***")
        docargs={
            'docs':obj_account_invo,
            'date':date.today()
        }
        return self.env['report'].render('account_report_invoice_johao.report_account_invoice',docargs) --> dentro del render se ponen el report_name del ir.actions.report.xml

#Estylos de report_xlsx
format_header=workbook.add_format({'bold':True,'font_size':'15px','border':True,'bg_color':'yellow'})
format_body=workbook.add_format({'font_size':'10px','border':True})
sheet.set_column('C:J',15)--> la celda C hasta J se anchara las columnas en un tamaño de 15
import base64
import io

 for t in obj_test:
	
            logo=io.BytesIO(base64.b64decode(t.get_logo()))
            sheet.insert_image(1,7,'image.png',{'image_data':logo,'x_scale':0.30,'y_scale':0.30})



#seguimiento
class Customer(models.Model):
    _name="module_test.customer"
    _inherit="mail.thread"

  #si deseamos saber que se creo un reguistros usamos el tracking=True en los campos que deseamos
  <div class="oe_chatter">
                    <field name="message_follower_ids" widget="mail_followers"/>
                    <!-- <field name="activity_ids"/> -->
                    <field name="message_ids" widget="mail_thread"/>
                </div>

El campo <field name="message_follower_ids" widget="mail_followers" groups="base.group_user"/> en Odoo se utiliza para gestionar los seguidores o suscriptores de un registro en particular.

Cuando este campo se muestra en una vista, proporciona una interfaz para que los usuarios puedan seguir o dejar de seguir el registro y recibir notificaciones relacionadas con los cambios o actualizaciones en el mismo.

El campo <field name="message_ids" widget="mail_thread"/> en Odoo se utiliza para gestionar los hilos de mensajes asociados a un registro específico.

Cuando este campo se muestra en una vista, proporciona una interfaz donde los usuarios pueden ver y participar en los hilos de mensajes relacionados con el registro en cuestión.

#OJO en los campos Many2many
pl_id=fields.Many2many(string="PL",comodel_name="purchase_albaran.order_production_plp")
para acceder a su ids se sua prin(self.pl_id.ids)--->[1,2,3] se usa ids por que son varios por ser un campo many2many , print(self.pl_id) --> purchase_albaran.order_production_plp(1, 2, 3)
 te mostrara los objetos  a diferencia de prin(self.pl_id.id)

#Api Antigua odoov8

cr (cursor): El parámetro cr representa el cursor de la base de datos. Es una conexión a la base de datos que permite realizar operaciones como lectura y escritura de datos. Se utiliza para ejecutar consultas SQL y realizar operaciones en la base de datos.

uid (user ID): El parámetro uid representa el ID del usuario que realiza la operación. Se utiliza para determinar los permisos y restricciones de acceso del usuario al realizar acciones en el modelo. Cada usuario en Odoo tiene un ID único asociado a él.

context: El parámetro context es un diccionario que proporciona información adicional y contexto durante la ejecución de los métodos del modelo. Puede contener información como el idioma preferido del usuario, valores predeterminados de campos, información contextual específica del negocio, entre otros.

para crear o actualizar un campo many2many 
new_record = self.env['model.name'].create({
    'field1': value1,
    'field2': value2,
    'presupuesto_ids': [(6, 0, [record_ids])]
})
y si deseas fltrar un objeto que tiene un campo many2many asociado a otra tabla  
obj_cine_gen=self.env['cinestar.genero'].search([('presupuesto_ids','in',[self.id])]) --> [self.id] aca puede ir un id o varios ids , te va a filtrar el id que este asociado ala otra tabla 
ejemplo si un registro tiene un campo many2many y su campo es presupeusto_id  y tiene asociado los ids 1,2,3  y al filtrar obj_cine_gen=self.env['cinestar.genero'].search([('presupuesto_ids','in',[1])])
me va  a flitrar el objeto que tiene relacione con id 1,2,3 

#Replace
texto='BS(1)'
new_text=texto.replace('BS(','').replace(')','')
print(int(type(new_text)) --> el replace remplaza lo que deseas por algo que deseas como en este ejemplo , estoy remplazando con un valor nada ''


#CONTROLADORES(controller)

from odoo import http
from odoo.http import request
from odoo import http
from odoo.http import request
from datetime import date

class Product(http.Controller):

    @http.route('/test',auth='public',website=True)
    def get_product(self,**kw):
        obj_pruchase_product=request.env['bodega.purchase_product'].search([])
        context={
            'purchase_product':obj_pruchase_product
        }
        return request.render('bodega.purchase_product',context)

<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <data>
        <template id="purchase_product">
            <t t-call="website.layout">
                <t t-foreach="purchase_product" t-as="p">
                    <t t-esc="p.name"/>
                </t>
            </t>
        </template>
    </data>
</odoo>
__manifest__.py

{
    #template
    'template/purchase_product.xml',
}

# -*- coding:utf-8 -*-
from odoo import http
from odoo.http import request
import json

class Product(http.Controller):
    
    @http.route('/product/create',type="http",auth="user")
    def create_product(self,**kwargs):
        create_product = request.env['product'].sudo().create({
            'name':'Cable Red 4G',
            'description':'Cable Red 4G',
            'price':1500,
            'quanty':2000,
            'purchase_id':1
        })
        create_product
        if create_product:
            context = {
                'message':'Se registro el product {}'.format(create_product.name)
            }
        else:
            context = {
                'message':'Error'
            }
        return json.dumps(context) 
    #Si dearas hacerlo con query seria asi 
     query1 = """
            SELECT name FROM purchase_order
        """
        request.env.cr.execute(query1)
        result_purchase_order = request.env.cr.dictfetchall()

    @http.route('/product', type="http" , auth="user")
    def get_product_all(self,**kwargs):
        objs_product = request.env['product'].sudo().search([])

        context_product = [{
            'id':p.id,
            'name':p.name,
            'description':p.description,
            'price':p.price,
            'quanty':p.quanty,
            'purchase_id':[{
                'name':p.purchase_id.name,
                'date':p.purchase_id.date.strftime("%Y:%m:%d")
            }],
        } for p in objs_product]

        context = json.dumps(context_product)
        return context
    
    @http.route('/product/<id_product>' , type="http" , auth="user")
    def search_product(self,**kwargs):

        product_id = kwargs.get('id_product',False)
        obj_product = request.env['product'].sudo().search([('id','=',product_id)])
        if obj_product:
            context_product = [{
                'id':p.id,
                'name':p.name,
                'description':p.description,
                'price':p.price,
                'quanty':p.quanty,
                'purchase_id':[{
                    'name':p.purchase_id.name,
                    'date':p.purchase_id.date.strftime("%Y:%m:%d")
                }],
            } for p in obj_product]

            context = json.dumps(context_product)
            return context
        else:
            return "No Existe El registro {}".format(product_id)
    
    @http.route("/product/update/<id_product>" , type="http" , auth="user")
    def update_product(self,**kwargs):
        id_product = kwargs.get('id_product',False)
        obj_product = request.env['product'].sudo().search([('id','=',id_product)])
        if id_product:
            if obj_product:
                obj_product.write({
                    'name':'Azure',
                    'purchase_id':2
                })
                context = {
                    'message':'Se actualizo Correctamente el registro {}'.format(id_product)
                }
                return json.dumps(context)
            else:
                context = {
                    'message':'Error no existe el registro {}'.format(id_product)
                }
                return json.dumps(context)
        else:
            context = {
                'message':'Error no existe el id {}'.format(id_product)
            }

    @http.route("/product/delete/<id_product>" , type="http" , auth="user")
    def delete_product(self,**kwargs):
        id_product = kwargs.get('id_product',False)
        obj_product = request.env['product'].sudo().search([('id','=',id_product)])
        if id_product:
            if obj_product:
                obj_product.unlink()
                context = {
                    'message':'Se elimino Correctamente el registro {}'.format(id_product)
                }
                return json.dumps(context)
            else:
                context = {
                    'message':'Error no existe el registro {}'.format(id_product)
                }
                return json.dumps(context)
        else:
            context = {
                'message':'Error no existe el id {}'.format(id_product)
            }         

#funcion copy()
la funcion copy por defecto copia un regsitro existente y copia ta como esta , es decir si tiene campos Many2many,Many2one,One2many y tiene registros los copia de todas maneras
-en la funcion copy no se puede ver el valor de los campos que se va a copiar, odoo por defecto lo hace , es decir no es visible por el programador al hacer print(values)
def copy(self,default=None):
  default=dict(default or {})
  return super(name_clase,self).copy(values)


#fields_view_get---> obtener las vistas form o treee o kababn de un model
from lxml import etree
import json
@api.model
	def fields_view_get(self, view_id=None, view_type='tree', toolbar=False, submenu=False):
		result = super(Programacion, self).fields_view_get(view_id=view_id, view_type=view_type, toolbar=toolbar, submenu=submenu)
		list_groups = self.get_groups_ids()
		if view_type == 'tree' and list_groups:
			doc = etree.XML(result['arch'])

			for field in result["fields"]:
				if field in list_groups:
					for node in doc.xpath("//field[@name='%s']" % field):
						modifiers = json.loads(node.get("modifiers")) --> el json.loads permite trasformar un json a un objeto python
						modifiers["readonly"] = False
						node.set("modifiers", json.dumps(modifiers)) --> el json.dumps() trasnforma un objeto python a json 
				else:
					for node in doc.xpath("//field[@name='%s']" % field):
						modifiers = json.loads(node.get("modifiers"))
						modifiers["readonly"] = True
						node.set("modifiers", json.dumps(modifiers))
			
			result['arch'] = etree.tostring(doc)
	
		return result   
    


El método fields_view_get es un método especial en Odoo que permite personalizar o extender las vistas de los modelos. Esta función es llamada para obtener la estructura de las vistas (formularios, listas, etc.) que se mostrarán en la interfaz de usuario para un modelo específico.

A continuación, te explicaré los parámetros que acepta el método fields_view_get:

self: Es el objeto en sí mismo, es decir, la instancia de la clase que está llamando al método. En el contexto de este método, self representa el registro actual del modelo.

view_id: Este parámetro opcional indica el ID de la vista que se está solicitando. Puedes utilizar este parámetro para determinar qué vista específica se está solicitando (por ejemplo, vista de formulario, vista de árbol, etc.).

view_type: Este parámetro indica el tipo de vista que se está solicitando. Puede tomar varios valores, como 'form' para la vista de formulario, 'tree' para la vista de lista (árbol), 'kanban' para la vista kanban, etc. Es útil para diferenciar entre los diferentes tipos de vistas en caso de que necesites realizar acciones específicas según el tipo de vista.

toolbar: Es un parámetro booleano que indica si la barra de herramientas (botones, acciones, etc.) debe mostrarse o no en la vista.

submenu: Es un parámetro booleano que indica si la vista es parte de un submenú o no.

El propósito principal de este método es permitir la personalización dinámica de las vistas según las necesidades del desarrollador o según ciertas condiciones específicas del modelo o del usuario. Puedes utilizar este método para ajustar la presentación de datos, ocultar o mostrar campos, agregar o eliminar elementos de la barra de herramientas y mucho más.

Es importante tener en cuenta que, si deseas utilizar este método, debes asegurarte de llamar correctamente a la función original fields_view_get de la superclase para evitar conflictos o errores en la interfaz de usuario.

#View Kanban
      <record id="bo_inmueble_kanban" model="ir.ui.view">
            <field name="name">bo_inmueble_kanban</field>
            <field name="model">bo.inmueble</field>
            <field name="arch" type="xml">
                <kanban>
                    <field name="name"/>
                    <field name="types"/>
                    <field name="price"/>
                    <field name="street"/>

                    <templates>
                        <t t-name="kanban-box"><!--kanban box hace la caja-->
                            <div t-attf-class="oe_kanban_content oe_kanban_global_click">
                                <strong><field name="name"/></strong>
                                <div>
                                    Direccion: <field name="street"/>
                                    Referencia: <field name="street_2"/>
                                    <t t-if="record.price.value >= 6000">
                                        Precio : <t t-esc="record.price.value" style="color:red"/>
                                    </t>
                                </div>
                            </div>
                        </t>
                    </templates>

                </kanban>
            </field>
        </record>

#Para levantar el odoo desde la consola referenciando al odoo.conf
python odoo-bin -c odoo.conf --> con el -c estamos indicando que ejecute el odoo-bin pero referenciando al odoo..conf
Model para usar archivos adjuntos
Podremos seleccionar archivos de nuestro escritorio,PDF,WORD,ETC y serian many2many mostrar con un logo de documento 
con el widget many2many_binary, este model es de la base de odoo
attachment_ids = fields.Many2many(string="Archivos Adjuntos",comodel_name="ir.attachment")
<field name="attachment_ids" widget="many2many_binary"/>

#En caso no este leyendo los estilos del PDF
en tecnico->parametors del sistema  ponemos report.url  http//:localhost:8069   , ahi otro que es web.base.url   http//:localhost:8069
# Para obtenerel value de campos selection se usa este codigo pero dentro del model(dentro de la class)

    TYPE_FAMILY = [
      ('all', 'Todos'),
      ('etiqueta', 'Etiquetas Autoadhesivas'),
      ('termo_enc', 'Termoencogibles'),
      ('bolsa', 'Bolsas'),
      ('empaque', 'Empaques Flexibles'),
      ('servicio', 'Servicio Especial')
    ]
familia=fields.Selection(string="Linea de Producto",selection=TYPE_FAMILY,readonly=True)
 @api.multi
    def get_selection_type_family(self):
      return (dict(self.env["cotizador_flexo.cotiza_valorizado"].fields_get(allfields=["familia"])["familia"]['selection'])[self.familia])

#Boostrap para Odoo
<div class ="d-flex flex-row"> --> esto hace que el contenido este en fila son class de boostrap,
puede usar flex-column
	<label for="" string=""/> esto es para usar label y el for se usa para dirrecionar al field
	<field name="" class="ml-1 mr-1"/> --> puedo usar ml-1(margin left) mr-1(margin right) etc
</div>

<p class="o_view_nocontend_smiling_face"> 
</p>
#En los expath para saber el 1 elemento, ultimo elemento
 <xpath expr="//notebook[last()]" position="inside">
#ojo 
date = fields.Date(default=fields.date.today()) --> esto capta la fecha de tu pc , es decir si modifico la fecha de mi maquina se reflejara en el odoo
es decir si estammos 14/11 pero en mi maquina esta 10/11 en el odoo mostrar la fecha 10/11
date = fields.Date(default=lambda self:fields.Date.context_today(self)) --> esto trae la fecha real 

#Data 
    <data>
        <record id="order_product_chaufa" model="order.product">
            <field name="name">Arroz Chaufa</field>
            <field name="stock">50</field>
            <field name="price">15</field>
            <field name="discount">10</field>
            <field name="image" type="base64" file="food_order/static/img/chaufa.png"/> --> de esta forma se agrega una imagen desde data 
        </record>
   </data>
#Frontend para caso de campos totalesm,impuesto
     <group class="oe_subtotal_footer oe_right"> --> usamos esta class , el nolabel="1" hace que no muestre la etiqueta(label) del field 
                                        <field name="amount_base" readonly="1"/>
                                        <field name="amount_tax" readonly="1"/>
                                        <field name="amout_total" readonly="1"/>
   </group>

<!--view Graph-->
<record id="movie_presupuesto_view_graph" model="ir.ui.view">
            <field name="name">movie.presupuesto.view.graph</field>
            <field name="model">movie.presupuesto</field>
            <field name="arch" type="xml">
                <graph string="Grafico">
                    <field name="customer_id" type="row"/>
                </graph>
            </field>
</record>
